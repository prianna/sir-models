//
//  CrossScale.h
//  CrossScaleSim class definition.


#ifndef __CrossScaleSim__CrossScale__
#define __CrossScaleSim__CrossScale__

#include "globals.h"
#include "ODESolver.h"
#include <random>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <queue>
#include <algorithm>

class CrossScaleSim
{
public:
    // Constructor.
    CrossScaleSim();
    
    // Destructor.
    ~CrossScaleSim()
    {
        delete population.front();
    }
    
    // Main iterative loop. This loop cycles through the a queue of infected
    // individuals, checking whether they have reached the critical threshold for
    // infection (V_CRIT). These individuals then enter the transmission phase
    // or are allowed to continue incubating the virus until V_CRIT is reached.
    // Calls the ODE solver to carry out within-host incubation period and
    // the transmission() function to calculate bottleneck width.
    void cycle()
    {
        // Checking to make sure that our vector of individuals
        // doesn't grow too large.
        if (population.size() >= POP_MAX)
        {
            cur_cycle = MAX_CYCLES;
            return;
        }
    
        // If there are newly infected individuals in the queue, waiting to transmit,
        // we check their viral load to make sure they have reached V_CRIT.
        else if ( !children.empty() )
        {
            while ( !children.empty() && generations <= MAX_GENS )
            {
                individual *parent = children.front();
                generations = parent->gen;
                double v_load = viral_Load(parent->v_0);
                
                if ( v_load < V_CRIT )
                {
                    std::vector<int> types = withinHost(parent);
                    transmission(types, parent);
                }
                else
                    transmission(parent->v_0, parent);
                
                population.push_back(parent);
                children.pop();
            }
            cur_cycle = MAX_CYCLES;
        }
        cur_cycle++;
    }
    
    
    // Accessor.
    int get_cycle()
    {
        return cur_cycle;
    }
    
    // Computes the average time taken to reach V_CRIT for all infected individuals.
    void avgTimeToCrit();

    // Returns vector containg R0 values.
    std::vector<double> get_avgt_crit()
    {
        return t_crit;
    }
    
    int get_gens()
    {
        return generations;
    }
    // Outputs a table of individuals and all relevant data to the console.
    void output_map();
    
    // Outputs the following: time created (t_0), viral load at t_0, generation
    // parent to respective files. 
    void output_data();
    
    void output_formatted();

private:
    
    // Node to contain data about individuals. Private struct, only accessed by
    // members of class CrossScaleSim.
    struct individual
    {
        double t_0; // Time created (relative to parent's t_crit).
        double t_crit; // Relative time to reach V_CRIT, from t_0.
        double t_abs; // Absolute time to reach V_CRIT.
        std::vector<int> v_0; // Viral types present at t_0.
        individual *parent; // Pointer to parent.
        std::vector<individual*> children; // Vector of pointers to children.
        int key; // Unique identifier.
        int gen; // Generation created.

        
        // default constructor, takes 3 parameters: time of infection, viral types
        // at infection, pointer to parent.
        individual( double tc, std::vector<int> vir_type, individual *parent, int ID, int gen)
        : t_0(tc), v_0(vir_type), parent(parent), key(ID), gen(gen), t_crit(tc), t_abs(0.0)
        {}
        
        // Destructor, to free up memory.
        ~individual()
        {
            for (int i = 0; i < children.size(); i++)
            {
                delete children[i];
            }
            children.clear();

        }
    };
    
        
    // Precondition: Time is a number drawn from a uniform distribution (0.0, T)
    // and vtypes is a vector containing the initial viral load of the parent.
    // Postcondition: A vector containing the viral load at t = time is returned.
    std::vector<double> betweenHost( double time_init, double time_fin, std::vector<int> vtypes );
    
    std::vector<int> withinHost( individual* parent );


    // Precondition: Parentvir contains the initial viral load of the parent.
    // Postcondition: The individual undergoes its transmission cycle, and
    // infects c children, where c is generated by poisson(B0*T). Each child
    // is added to the individual's children vector.
    void transmission( std::vector<int> parentvir, individual* parent );
    
    // Sums the individual strains to compute the total viral load.
    // Input: Vector of viral strains.
    // Output: Total viral load.
    int viral_Load( std::vector<int> v_0 )
    {
        int viral_load = 0;
        
        for (int i = 0; i < K; i++)
        {
            viral_load += v_0[i];
        }
        
        return viral_load;
    }
    
    std::uniform_real_distribution<double> unif; // Uniform distribution.
    std::mt19937 gen; // Mersenne Twister RNG.
    std::poisson_distribution<> poiss; // Poisson distribution.
    std::vector<individual*> population;
    std::queue<individual*> children;
    
    // Initial vector of viral loads.
    std::vector<int> V_0;
    std::vector<double> t_crit;
    double avgt_crit;
    int generations, cur_cycle;
};


#endif /* defined(__CrossScaleSim__CrossScale__) */
