//
//  CrossScale.h
//  CrossScaleSim class definition.


#ifndef __CrossScaleSim__CrossScale__
#define __CrossScaleSim__CrossScale__

#include "globals.h"
#include "ODESolver.h"
#include <random>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <queue>
#include <algorithm>

class CrossScaleSim
{
public:
    // Constructor.
    CrossScaleSim();
    
    // Destructor.
    ~CrossScaleSim()
    {
        delete population.front();
    }
    
    // Main iterative loop. This loop cycles through the a queue of infected
    // individuals, checking whether they have reached the critical threshold for
    // infection (V_CRIT). These individuals then enter the transmission phase
    // or are allowed to continue incubating the virus until V_CRIT is reached.
    // Calls the ODE solver to carry out within-host incubation period and
    // the transmission() function to calculate bottleneck width.
    void cycle();
    
    
    // Accessor.
    int get_generations()
    {
        return generations;
    }
    
    int get_pop()
    {
        return population.size();
    }
    
    // Computes the average time taken to reach V_CRIT for all infected individuals.
    void avgTimeToCrit();

    // Returns vector containg R0 values.
    std::vector<double> get_avgt_crit()
    {
        return t_crit;
    }
    
    // Outputs a table of individuals and all relevant data to the console.
    void output_map();
    
    // Outputs the following: time created (t_0), viral load at t_0, generation
    // parent to respective files. 
    void output_data();
    
    void output_formatted();

private:
    
    // Node to contain data about individuals. Private struct, only accessed by
    // members of class CrossScaleSim.
    struct individual
    {
        double t_0; // Time created (relative to parent's t_crit).
        double t_crit; // Relative time to reach V_CRIT, from t_0.
        double t_abs; // Absolute time to reach V_CRIT, from 0.
        std::vector<int> v_0; // Viral types present at t_0.
        individual *parent; // Pointer to parent.
        std::vector<individual*> children; // Vector of pointers to children.
        int key; // Unique identifier.
        int gen; // Generation created.
        int contacts;

        
        // Default constructor, takes 3 parameters: time of infection, viral types
        // at infection, pointer to parent.
        individual( double tc, std::vector<int> vir_type, individual *parent, int ID, int gen)
        : t_0(tc), v_0(vir_type), parent(parent), key(ID), gen(gen), t_crit(tc), t_abs(0.0)
        {}
        
        // Destructor, to free up memory.
        ~individual()
        {
            for (int i = 0; i < children.size(); i++)
            {
                delete children[i];
            }
            children.clear();

        }
    };
    
        
    // Precondition: time_fin is a number drawn from a uniform distribution (0.0, T)
    // and vtypes is a vector containing the initial viral load of the parent.
    // Postcondition: A vector containing the viral load at t = time is returned.
    std::vector<double> betweenHost( double time_init, double time_fin, std::vector<int> vtypes );
    
    
    // Precondition: parent is an object of type individual whose viral load has
    // not yet reached v_crit.
    // Postcondition: The viral load of parent is now v_crit. Returns parent's viral
    // load vector.
    std::vector<int> withinHost( individual* parent );


    // Precondition: Parentvir contains the initial viral load of the parent.
    // Postcondition: The individual undergoes its transmission cycle, and
    // infects c children, where c is generated by poisson(B0*T). Each child
    // is added to the individual's children vector.
    void transmission( std::vector<int> parentvir, individual* parent );
    
    // Sums the individual strains to compute the total viral load.
    // Input: Vector of viral strains.
    // Output: Total viral load.
    int viral_Load( std::vector<int> v_0 )
    {
        int viral_load = 0;
        
        for (int i = 0; i < K; i++)
        {
            viral_load += v_0[i];
        }
        
        return viral_load;
    }
    
    std::mt19937 randomgen; // Mersenne Twister RNG.
    std::vector<individual*> population;
    std::queue<individual*> children;
    
    // Initial vector of viral loads.
    std::vector<int> V_0;
    std::vector<double> t_crit;
    double avgt_crit;
    int generations;
};


#endif /* defined(__CrossScaleSim__CrossScale__) */
